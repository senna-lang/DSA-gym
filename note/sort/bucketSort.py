"""
バケットソート (Bucket Sort) の実装

各要素を適切なバケット（区間）に振り分けてソートするアルゴリズム

計算量:
- 最良: O(N)
- 平均: O(N + K) (K: バケット数)
- 最悪: O(N^2) (全要素が1つのバケットに集中した場合)

空間計算量: O(N + K)

特徴:
- 要素の値の範囲が分かっている場合に効率的
- 安定ソートではない（実装による）
- 分布が均等な場合に高速
"""


def bucket_sort(a: list[int]) -> None:
    """
    配列をバケットソートでソートする (in-place)

    前提条件: 最大値 MAX が既知（ここでは 100000 と仮定）

    手順:
    1. 各要素の出現回数をカウント
    2. 累積和を計算して、各要素のソート後の位置を決定
    3. 累積和を使って要素を正しい位置に配置

    Args:
        a: ソート対象の配列

    例:
        a = [5, 2, 8, 2, 9]
        bucket_sort(a) -> a = [2, 2, 5, 8, 9]
    """
    MAX = 100000
    N = len(a)

    # 各要素の出現回数をカウントする
    # num[i] = 値 i の出現回数
    num = [0] * (MAX + 1)
    for i in range(N):
        num[a[i]] += 1

    # 累積和を計算する
    # num[v] = 値 v 以下の要素の個数
    # つまり、値 v のソート後の位置範囲を表す
    for v in range(1, MAX + 1):
        num[v] += num[v - 1]

    # この時点で:
    # num[v-1] = 値 v より小さい要素の個数
    # num[v]   = 値 v 以下の要素の個数
    # したがって、値 v の要素は num[v-1] から num[v]-1 の範囲に配置される

    # 累積和を使って要素を正しい位置に配置
    a2 = [0] * N

    # 配列を後ろから走査（安定ソートにするため）
    for i in range(N - 1, -1, -1):
        # a[i] の値を取得
        value = a[i]

        # num[value] は「value 以下の要素の個数」
        # つまり、value の最後の位置 + 1
        # したがって、num[value] - 1 が value を配置すべき位置
        a2[num[value] - 1] = a[i]

        # 次に同じ値が来た時のために、カウントを1減らす
        num[value] -= 1

    # ソート結果を元の配列にコピー
    for i in range(N):
        a[i] = a2[i]

